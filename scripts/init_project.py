#!/usr/bin/env python3
"""Initialize .clarity/ and scenarios/ directories in a project.

Usage:
    uv run ~/.claude/skills/clarity/scripts/init_project.py [project_path]
    uv run ~/.claude/skills/clarity/scripts/init_project.py --install-companions

If project_path is omitted, uses the current working directory.
Idempotent — safe to run multiple times.

Flags:
    --install-companions  Create symlinks for companion skills (e.g. /linear-walkthrough)
"""

import sys
from pathlib import Path

CLARITY_DIRS = [
    ".clarity",
    ".clarity/evaluations",
    "scenarios",
]

SCENARIOS_README = """\
# Scenarios — Holdout Test Set

This directory contains behavioral scenarios generated by the `/clarity` skill.

**IMPORTANT**: These scenarios are a *holdout set* for evaluation.
Implementation agents must **never** read this directory during development.

Each scenario follows Given/When/Then format with a concrete verification method.

## Naming Convention

`SC-NNN-short-slug.scenario.md`

- `NNN`: zero-padded sequence number
- `short-slug`: kebab-case summary of the scenario
"""

GITIGNORE_COMMENT = "# clarity skill artifacts\n"
GITIGNORE_ENTRIES = [
    ".clarity/",
    "scenarios/",
]


def init_project(project_path: Path) -> None:
    if not project_path.is_dir():
        print(f"Error: {project_path} is not a directory", file=sys.stderr)
        sys.exit(1)

    # Create directories
    for d in CLARITY_DIRS:
        target = project_path / d
        target.mkdir(parents=True, exist_ok=True)
        print(f"  {'exists' if target.exists() else 'created'}: {d}/")

    # Write scenarios/README.md if missing
    readme = project_path / "scenarios" / "README.md"
    if not readme.exists():
        readme.write_text(SCENARIOS_README)
        print("  created: scenarios/README.md")
    else:
        print("  exists:  scenarios/README.md")

    # Suggest .gitignore entries (don't auto-modify — user's choice)
    gitignore = project_path / ".gitignore"
    missing = []
    if gitignore.exists():
        content = gitignore.read_text()
        for entry in GITIGNORE_ENTRIES:
            if entry not in content:
                missing.append(entry)
    else:
        missing = GITIGNORE_ENTRIES

    if missing:
        print(f"\n  Tip: consider adding to .gitignore:")
        for entry in missing:
            print(f"    {entry}")

    print("\nDone. Project initialized for /clarity.")


COMPANION_SKILLS = {
    "linear-walkthrough": "Generates zero-hallucination codebase walkthroughs",
}


def install_companions(clarity_dir: Path) -> None:
    """Create symlinks for companion skills so they're discoverable."""
    skills_dir = clarity_dir.parent  # e.g. ~/.claude/skills/

    for name, desc in COMPANION_SKILLS.items():
        source = clarity_dir / name
        target = skills_dir / name

        if not source.is_dir():
            print(f"  skip: {name}/ (source not found in clarity)")
            continue

        if target.exists() or target.is_symlink():
            if target.is_symlink() and target.resolve() == source.resolve():
                print(f"  exists: {name} -> {source}")
            else:
                print(f"  skip: {target} already exists (not a clarity symlink)")
            continue

        target.symlink_to(source)
        print(f"  linked: {name} -> {source}")
        print(f"          {desc}")

    print("\nCompanion skills installed. Restart Claude Code to pick them up.")


def main() -> None:
    args = [a for a in sys.argv[1:] if not a.startswith("--")]
    flags = {a for a in sys.argv[1:] if a.startswith("--")}

    if "--install-companions" in flags:
        # Find clarity's own directory (where this script lives)
        clarity_dir = Path(__file__).resolve().parent.parent
        print(f"Installing companion skills from: {clarity_dir}\n")
        install_companions(clarity_dir)
        if not args:
            return

    if args:
        project_path = Path(args[0]).resolve()
    else:
        project_path = Path.cwd()

    print(f"Initializing clarity in: {project_path}\n")
    init_project(project_path)


if __name__ == "__main__":
    main()
